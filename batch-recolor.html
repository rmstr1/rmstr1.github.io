<!doctype html>

<html>

<head>
    <style>
        :root {
            /*--foreground: #38ac8f;*/
            --foreground: #fafafa;
            --bg: #272727;
            --border-radius: 2rem;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-flow: column nowrap;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;

            width: 100vw;
            margin: 0;
            padding: 2rem;

            background-color: var(--bg);
            color: var(--foreground);

            font-family: monospace;
            font-size: 1rem;
            font-weight: 400;
            /*1px*/
        }

        #navbar {
            justify-content: right;
        }

        button {
            all: unset;
            box-sizing: border-box;

            white-space: nowrap;
            text-align: center;
            letter-spacing: 0.1500rem;

            padding: 1rem 2rem;
            cursor: pointer;

            color: #fafafa;
            background-color: #ec1e40;
            box-shadow: 0.25rem 0.25rem 0.125rem #00000022;
            transition: all 0.15s ease-out;
        }

        button:hover {
            background-color: #acacac;
        }

        .save {
            font-size: 1.25rem;
            padding: 1rem 2rem;
            border-radius: 1rem;
        }

        .edit {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            background-color: #808080;
        }

        .v-container {
            width: 100%;
            max-width: 52rem;
            margin: 1rem;
            padding: 2rem;
            display: flex;
            flex-flow: column nowrap;
            align-items: left;
            justify-content: center;
        }

        .h-container {
            width: 100%;
            max-width: 52rem;
            display: flex;
            justify-content: left;
            align-items: center;
            flex-wrap: wrap;
        }

        .color-changer {
            display: flex;
            flex-flow: column nowrap;
            justify-content: center;
            align-items: center;
        }

        #drop-zone {
            width: 100%;
            max-width: 52rem;
            display: flex;
            flex-flow: column nowrap;
            align-items: center;
            justify-content: center;

            margin: 1rem;
            padding: 2rem;
            border: dashed 0.125rem #8b8b8b;
            border-radius: var(--border-radius);
        }

        #image-container {
            min-height: 300px;
        }

        #colors-border {
            border-radius: var(--border-radius);
            background-color: #444444;
        }

        #colors-container {
            border-radius: var(--border-radius);
            margin: 1rem;
            padding: 2rem;
        }

        #recolor-border {
            border-radius: var(--border-radius);
            background-color: #444444;
        }

        #recolor-container {
            margin: 1rem;
            padding: 2rem;
        }

        canvas {
            height: 100px;
            image-rendering: pixelated;
        }

        input[type=color] {
            height: 2rem;
            width: 2rem;
            padding: 0;
            cursor: pointer;
        }

        input[type=checkbox] {
            appearance: none;
            height: 1.5rem;
            width: 1.5rem;
            margin: 1px;
            padding: 0;
            cursor: pointer;
            border: dotted 0.125rem #222222;
            accent-color: #000000;
            background-color: #000000;
        }

        input[type=checkbox]:hover {
            border: solid 0.125rem #ffffff;
        }

        input[type=checkbox]:checked {
            appearance: auto;
            border: solid 0.125rem #ffffff;
        }
    </style>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Batch Recolor (BETA)">
    <title>Batch Recolor (BETA)</title>
</head>

<body>
    <div id="navbar" class="h-container">
        <button onclick="saveImages()" class="save">Save changes</button>
    </div>
    <div id="colors-border" class="v-container">
        <div>
            +++ Select the colors you want to edit +++
        </div>
        <div id="colors-container" class="h-container">
            Image colors will appear here; Images should only contain up to 256 different colors.
        </div>
    </div>
    <div id="recolor-border" class="v-container">
        <div>
            +++ Edit colors +++
        </div>
        <div id="recolor-container" class="h-container">
            Colors selected for editing will appear here.
        </div>
        <div class="h-container">
            <button onclick="resetColors()" class="edit">Reset colors</button>
        </div>
    </div>
    <div id="drop-zone" ondrop="dropHandler(event);" ondragover="dragOverHandler(event);">
        <h2>+++ Drag and drop files and folders here +++</h2>
        <div id="image-container" class="h-container">
        </div>
    </div>
    <script>
        const hsluv = window.hsluv;
        console.log(hsluv);

        const file_mapping = new Map();
        const color_set = new Set();
        const color_mapping = new Map();

        const dropHandler = async (ev) => {
            console.log('File(s) dropped');

            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();

            // load and save files with File System Access API
            await Promise.all([...ev.dataTransfer.items].map(async (item, i) => {
                const handle = await item.getAsFileSystemHandle();
                await recursivelyOpenFiles(handle, file_mapping);
            }));

            // update color picker view
            const colors_container = document.getElementById("colors-container");
            colors_container.textContent = '';
            let colors_array = Array.from(color_set).slice(0, 256); // 256 max_n colors
            //colors_array.sort((a, b) => sortByHLuvS(a, b));
            colors_array.forEach((color) => {
                var color_checkbox = document.createElement("input");
                color_checkbox.setAttribute("type", "checkbox");
                color_checkbox.style.backgroundColor = color;
                color_checkbox.style.accentColor = color;

                color_checkbox.onchange = () => {
                    if (color_checkbox.checked) {
                        color_mapping.set(color, color);
                        updateColorMappingView();
                    } else {
                        color_mapping.delete(color)
                        reDrawAllImages();
                        updateColorMappingView();
                    }
                }

                colors_container.appendChild(color_checkbox);
            });
        }

        const recursivelyOpenFiles = async (handle, file_mapping) => {
            const image_container = document.getElementById("image-container");

            return new Promise(async (resolve, reject) => {
                if (handle.kind === 'file') {
                    // TODO: if file has not been uploaded or started uploading already
                    if (file_mapping.get(handle) === undefined) {
                        file_mapping.set(handle, null);

                        const file = await handle.getFile();

                        const reader = new FileReader();
                        reader.onload = async (ev) => {
                            const image = new Image();
                            image.title = file.name;
                            image.src = reader.result;

                            image.onload = () => {
                                const onscreen_canvas = document.createElement('canvas');
                                onscreen_canvas.width = image.width;
                                onscreen_canvas.height = image.height;

                                image_container.appendChild(onscreen_canvas);

                                file_mapping.set(handle, [image, onscreen_canvas]);

                                extractColors(image);
                                drawImageWithColorChange(image, onscreen_canvas);

                                resolve();
                            }

                            image.onerror = () => {
                                resolve();
                            }

                            image.onabort = () => {
                                resolve();
                            }
                        };
                        reader.readAsDataURL(file);
                    }
                } else {
                    // directory
                    console.log(`Directory: ${handle.name}`);
                    for await (const entry of handle.values()) {
                        console.log(entry.kind, entry.name);
                        await recursivelyOpenFiles(entry, file_mapping);
                    }
                    resolve();
                }
            });
        }

        const updateColorMappingView = () => {
            const recolor_container = document.getElementById("recolor-container");
            recolor_container.textContent = '';
            let colors_array = Array.from(color_mapping)
            //colors_array.sort(([a, recolor_a], [b, recolor_b]) => sortByLuvHS(a, b));
            colors_array.forEach(([from_color, to_color]) => {
                var from_color_view = document.createElement("input");
                from_color_view.setAttribute("type", "checkbox");
                from_color_view.style.backgroundColor = from_color;
                from_color_view.style.accentColor = from_color;

                var to_color_view = document.createElement("input");
                to_color_view.setAttribute("type", "color");
                to_color_view.value = to_color;
                //to_color_view.oninput = (event) => { applyColorChange(from_color, event.target.value); }; // TODO: checkbox to disable
                to_color_view.onchange = (event) => { applyColorChange(from_color, event.target.value); };

                const color_changer = document.createElement('div');
                color_changer.className = 'color-changer';

                color_changer.append(from_color_view, 'â¬‡', to_color_view);

                recolor_container.appendChild(color_changer);
            });
        }

        const resetColors = () => {
            for (key of color_mapping.keys()) {
                color_mapping.set(key, key);
            }
            updateColorMappingView();
            reDrawAllImages();
        }

        const applyColorChange = (from_color, to_color) => {
            color_mapping.set(from_color, to_color);
            reDrawAllImages();
        }

        const reDrawAllImages = () => {
            file_mapping.forEach(([image, canvas], _handle) => {
                drawImageWithColorChange(image, canvas)
            });
        }

        const drawImageWithColorChange = (image, canvas) => {
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0);
            const imageData = context.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const hex = rgbToHex(data[i], data[i + 1], data[i + 2]);
                const mapped_color_hex = color_mapping.get(hex);
                if (mapped_color_hex !== undefined && mapped_color_hex !== null) {
                    [r, g, b] = hexToRgb(mapped_color_hex);
                    data[i] = r;
                    data[i + 1] = g; // green
                    data[i + 2] = b; // blue
                }
            }
            context.putImageData(imageData, 0, 0);
        };

        const extractColors = (image) => {
            let tmp_canvas = new OffscreenCanvas(image.width, image.height);
            const context = tmp_canvas.getContext("2d");
            context.drawImage(image, 0, 0);
            const imageData = context.getImageData(0, 0, tmp_canvas.width, tmp_canvas.height);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i + 3] > 0) {
                    color_set.add(rgbToHex(data[i], data[i + 1], data[i + 2]));
                }
            }
        }

        const rgbToHex = (r, g, b) => {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        const hexToRgb = (hex) =>
            hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i
                , (m, r, g, b) => '#' + r + r + g + g + b + b)
                .substring(1).match(/.{2}/g)
                .map(x => parseInt(x, 16));

        const saveImages = () => {
            file_mapping.forEach(([image, _canvas], handle) => {
                //drawImageWithColorChange(image, canvas);
                //canvas.toBlob(async (blob) => { await saveFile(handle, blob) });
                let offscreen_canvas = new OffscreenCanvas(image.width, image.height);
                drawImageWithColorChange(image, offscreen_canvas);
                offscreen_canvas.convertToBlob().then(async (blob) => { await saveFile(handle, blob) });
            });
        };

        const saveFile = async (handle, blob) => {
            const writableStream = await handle.createWritable();
            await writableStream.write(blob);
            await writableStream.close();
        }

        const dragOverHandler = (ev) => {
            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();
        }
    </script>
</body>

</html>